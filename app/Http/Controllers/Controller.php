<?php

namespace App\Http\Controllers;

use Illuminate\Routing\Controller as BaseController;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use App\Models\GeneralPurpose\RequestOptions;
use Illuminate\Http\Response;
use Illuminate\Http\Request;
use Carbon\Carbon;
use App\Models\Vial;
use App\Models\Prescription;

class Controller extends BaseController
{
    protected $AllowedFields = null;
    protected $RequestOptions = null;

    /**
     * handleRequest - The general purpose, do all function
     * @param  Request $request The API request
     * @param  String  $class   Path to class ie: 'App\Models\Login'
     * @return Response         A response upon completion
     */
    protected function handleRequest(Request $request, $Object)
    {
        $this::getRequestOptions($request, $Object);
        switch (strtoupper($request->method())) {
            case 'GET':
                if (is_null($this->RequestOptions->id)) {
                    return $this->getManyFromRequest($Object);
                } else {
                    return $this->getOneFromRequest($Object);
                }
                // no break
            case 'PUT':
                $this->fixWriteRequest($request);
                return $this->updateFromRequest($request, $Object);
            case 'POST':
                $this::fixWriteRequest($request);
                if ($this->RequestOptions->isSearch) {
                    return $this->searchFromRequest($request, $Object);
                } else {
                    return $this->createFromRequest($request, $Object);
                }
            // no break
            case 'DELETE':
               return $this->deleteFromRequest($Object);
        }
    }

    /**
     * Used to modify the request object prior to create/update
     * @param  Request $request [description]
     * @return [type]           [description]
     */
    protected function fixWriteRequest(Request $request)
    {
        return null;
    }

    /**
     * The general purpose create API endpoint entry method, just a wrapper
     * for validateAndSave
     * @param  Request $request The API request
     * @param  [type]  $Object  An object of the class to be created
     * @return Response         The response generated by validateAndSave
     */
    protected function createFromRequest(Request $request, $Object)
    {
        return $this->validateAndSave($request, $Object);
    }

    /**
     * The general purpose update API endpoint entry method. Finds the object
     * to update and then calls validateAndSave and returns the response
     * @param  Request $request The API request
     * @param  [type]  $Object  An object of the class to be updated
     * @param  [type]  $id      The id of the object to update
     * @return Response         The response generated by validateAndSave
     */
    protected function updateFromRequest(Request $request, $Object)
    {
        try {
            $Query = $this->queryWith($Object);
            $Query = $this->queryWhere($Query);
            if (method_exists($Object, 'withTrashed')) {
                $Query = $Query->withTrashed(); //allows updates to softDeletes
            }
            $Object = $Query->findOrFail($this->RequestOptions->id);
            return $this->validateAndSave($request, $Object);
        } catch (ModelNotFoundException $e) {
            return response()->json('Resource could not be located.', 404);
        }
    }

    /**
     * The general purpose delete API endpoint entry method. Gets the request
     * options, finds the object in question, marks it as deleted and returns
     * A copy of the deleted object.
     * @param  Request $request The API request
     * @param  [type]  $Object  An object of the class to be deleted
     * @param  [type]  $id      The id of the object to be deleted
     * @return Response         The response generated by the finishAndFilter method
     */
    protected function deleteFromRequest($Object)
    {
        try {
            $Query = $this->queryWith($Object);
            $Query = $this->queryWhere($Query);
            $Object = $Query->findOrFail($this->RequestOptions->id);
            $Object = $Object->markDeleted($this->RequestOptions);
            return $this->finishAndFilter($Object);
        } catch (ModelNotFoundException $e) {
            return response()->json('Resource could not be located.', 404);
        }
    }

    /**
     * The general purpose read one API endpoint entry method. Gets the
     * request options, finds the object in question and returns the
     * result of the finishAndFilter method
     * @param  Request $request The API request
     * @param  [type]  $Object  An object of the class to be found
     * @param  [type]  $id      The id of the object to be found
     * @return Response         The response returned by the finishAndFilter method
     */
    protected function getOneFromRequest($Object)
    {
        try {
            $Query = $this->queryWith($Object);
            $Query = $this->queryWhere($Query);
            if (method_exists($Object, 'withTrashed')) {
                $Query = $Query->withTrashed(); //allows updates to softDeletes
            }
            $Object = $Query->findOrFail($this->RequestOptions->id);
            return $this->finishAndFilter($Object);
        } catch (ModelNotFoundException $e) {
            return response()->json('Resource could not be located', 404);
        }
    }

    /**
     * The general purpose read many API endpoint entry method. Gets the request
     * options and reads the objects from the database. Returns the response
     * generated by the finishAndFilter method
     * @param  Request $request The API request
     * @param  [type]  $Object  An object of the class to be read
     * @return Response         The response generated by the finishAndFilter method
     */
    protected function getManyFromRequest($Object)
    {
        // join to other tables/objects
        $Query = $this->queryWith($Object);
        $Query = $this->queryWhere($Query);
        // Other modifiers looking to get
        $Query = $this->queryModifier($Query);
        $Query = $this->querySort($Query);
        if (!is_null($this->RequestOptions->limit) || !is_null($this->RequestOptions->offset)) {
            $this->getTotal($Query);
            $Query = $Query->limitOffset($this->RequestOptions->limit, $this->RequestOptions->offset);
        }
        $Objects = $Query->get();

        return $this->finishAndFilter($Objects);
    }


    /**
     * The general purpose search API endpoint entry method. Gets the request
     * options, converts the request into a search object, then performs the
     * search and returns the response generated by the finishAndFilter method
     * @param  Request $request The API request
     * @param  [type]  $Object  An object of the class to search for
     * @return Response         The response generated by the finishAndFilter method.
     */
    protected function searchFromRequest(Request $request, $Object)
    {
        $Query = $this->queryWith($Object);
        $Query = $this->queryWhere($Query);
        $Query = $this->queryModifier($Query);
        $Query = $Query->search($request);
        $Query = $this->querySearchModifier($Query);
        $Query = $this->querySort($Query);
        if (!is_null($this->RequestOptions->limit) || !is_null($this->RequestOptions->offset)) {
            $this->getTotal($Query);
            $Query = $Query->limitOffset($this->RequestOptions->limit, $this->RequestOptions->offset);
        }
        $Objects = $Query->get();

        return $this->finishAndFilter($Objects);
    }

    protected function getTotal($Query)
    {
        $this->RequestOptions->total_results = $Query->count();
    }

    protected function querySearchModifier($Query)
    {
        return $Query;
    }

    protected function querySort($Query)
    {
        \Log::info(json_encode($this->RequestOptions->sort));
        if (sizeOf($this->RequestOptions->sort) > 0) {
            // now attach the order by clauses to the query
            foreach ($this->RequestOptions->sort as $SortItem) {
                $Query = $Query->orderBy($SortItem->property, $SortItem->direction);
            }
        }
        return $Query;
    }

    /**
     * getRequestOptions builds the filter used to ensure that only the requested
     * columns are returned of every and extracts limit and offset from the request
     * if present.
     * @param  request $request    The API request
     * @return RequestOptions       An object containing the filter array as well
     *                              as the limit and offset values.
     */
    protected function getRequestOptions(request $request, $Object = null)
    {
        //make an init object for anything that needs to be returned
        $Options = !isset($this->RequestOptions) ? new RequestOptions() : $this->RequestOptions;
        $QueryParams = $request->query();
        $Fields = isset($QueryParams['fields']) ? $QueryParams['fields'] : null;
        $Limit = isset($QueryParams['limit']) ? $QueryParams['limit'] : null;
        $Offset = isset($QueryParams['offset']) ? $QueryParams['offset'] : null;

        $TotalResults = null;

        $Options->filter = $this->buildFilter($Fields);
        $Options->offset = $Offset;
        $Options->limit = $Limit;
        $Options->total_results = $TotalResults;
        $Options->sort = $this->buildSort($QueryParams, $Object);
        // sometimes I make a new request object from within the api and those
        // have no user attached. In those cases, I preset the user data I care
        // about using info from the actual users request. In those cases I
        // dont want to overwrite that data.
        if (!isset($Options->user)) {
            $Options->user = $request->user();
        }
        if (!isset($Options->user_id)) {
            $Options->user_id = $Options->user['user_id'];
        }
        $Options->method = strtoupper($request->method());
        $Options->isSearch = false;

        $pathArray = explode('/', $request->path());
        //If the last element in the array is set, its the id of the resource in question.
        $possibleId = $pathArray[sizeof($pathArray) - 1];
        if (is_numeric($possibleId)) {
            $Options->id = $possibleId;
        } else {
            $Options->id = null;
        }
        while (sizeof($pathArray) > 0) {
            $element = array_pop($pathArray);
            if ($element === '_search') {
                $Options->isSearch = true;
            } elseif (is_numeric($element)) {
                $resource = array_pop($pathArray);
                $propertyName = $resource."_id";
                $Options->$propertyName = $element;
            }
            //if its not numeric or _search... its weird and I dont know what will happen
        }

        $Options->isCreate = !$Options->isSearch && strtoupper($request->method()) === 'POST';
        $Options->request = $request;

        $this->RequestOptions = $Options;
        $this::init();
    }

    protected function init()
    {
        return;
    }

    protected function queryWhere($Query)
    {
        return $Query;
    }

    /**
     * API users may provide a csv list of fields that they want included in the
     * response. This function extracts those with a request and combines them with an
     * optional list of restrictions to generate an of properties that should be
     * returned
     * @param          $request      API requested fields (not full request object)
     * @param    $restrictions of fields this endpoint is allowed to return.
     * @return                 of properties the api should respond with or
     *                               -1 if full object should be returned
     */
    protected function buildFilter($request)
    {
        $restrictions = $this->AllowedFields;
        $requestedProps = preg_replace('/\s+/', '', $request);
        $requestedPropsArray = explode(',', $requestedProps);
        if (is_null($restrictions) && is_null($request)) {
            return -1;
        } elseif (!is_null($restrictions)) {
            if (!is_null($request)) {
                //remove any requested props that are not in the restrictions list
                foreach ($requestedPropsArray as $key => $value) {
                    if (array_search($value, $restrictions)===false) {
                        unset($requestedPropsArray[$key]);
                    }
                }
            } else {
                $requestedPropsArray = $restrictions;
            }
        }
        return $requestedPropsArray;
    }

    protected function buildSort($QueryParams, $Object)
    {
        $Sort = [];
        if (isset($QueryParams['sort']) && !is_null($Object)) {
            // build sorting data
            $TableColumns = $Object->getTableColumns();
            $SortString = $QueryParams['sort'];
            $SortArray = explode(',', $SortString);
            foreach ($SortArray as $sortItem) {
                $ArrayItem = explode(':', $sortItem);
                if (sizeOf($ArrayItem) === 2 && (strtoupper($ArrayItem[1]) === 'ASC' || strtoupper($ArrayItem[1]) === 'DESC')) {

                    // if they didn't give us all of the data we will ignore it

                    // First we have to do the name conversion from the api
                    // property names to the database column names
                    $Column = $ArrayItem[0];
                    $ConvertedName = array_search($Column, $Object::$DBtoRestConversion);
                    if ($ConvertedName) {
                        //If the db column name is in the conversion table,
                        //use we will search the request for the converted name
                        $Name = $ConvertedName;
                    } elseif (array_search($Column, $TableColumns)) {
                        //if its a real property name, use it
                        $Name = $Column;
                    } else {
                        $Name = null;
                    }
                    if (!is_null($Name)) {
                        $SortObj = app()->make('stdClass');
                        $SortObj->property = $Name;
                        $SortObj->direction = strtolower($ArrayItem[1]);
                        array_push($Sort, $SortObj);
                    }
                }
            }
        }
        return $Sort;
    }

    /**
     * The database schema and naming can be confusing. The API makes an effort
     * to isolate the user from this confusion by choosing more appropriate names
     * for certain properties. This function converts an API request from user-
     * friendly naming to DB naming and applies them to the provided object.
     * @param request $request API request
     * @param mixed   $Object  Object to apply new properties to and return
     */
    protected static function APItoDB(request $request, $Object)
    {
        $TableColumns = $Object->getTableColumns();
        foreach ($TableColumns as $Column) {
            if (array_key_exists($Column, $Object::$DBtoRestConversion)) {
                //If the db column name is in the conversion table,
                //use we will search the request for the converted name
                $Name = $Object::$DBtoRestConversion[$Column];
            } else {
                //otherwise, don't convert the name
                $Name = $Column;
            }
            //if the request includes a field for this column,
            //update the object to the new column value
            if ($request->input($Name) !== null) {
                $Object->$Column = $request->input($Name);
            }
        }
        return $Object;
    }

    /**
     * Calls the objects validator. If validation is successful, calls
     * The saveAndQuery method and return the result. If not successful,
     * returns the objects errors.
     * @param  request $request API request
     * @param  [type]  $Object  Object being updated or null during create
     * @return response           response to be returned to client
     */
    protected function validateAndSave(request $request, $Object = null)
    {
        if ($this->getLock()) {
            $request = $this->fixCreatedUpdatedInfo($request);

            if ($Object->validate($request->all(), $this->RequestOptions->id)) {
                return $Object = $this->saveAndQuery($request, $Object);
            } else {
                return response()->json($Object->errors(), 400);
            }
        } else {
            return response()->json('Another user currently owns one or more locks required to perform this action. Please try again later.', 401);
        }
    }

    protected function fixCreatedUpdatedInfo(request $request)
    {
        //this is also a convenient place to ensure no created_at/updated_at info makes it in to the db
        //from the user input.
        $requestData = $request->except(['created_at','updated_at','created_by','updated_by']);
        $request->replace($requestData);
        //Now lets explicitly set the correct values in case the model supports these.
        $Now = \DB::select('select now()')[0]->{'now()'};
        if ($this->RequestOptions->isCreate) {
            //The db will handle setting created at but we should set created_by if we can
            if (!is_null($request->user())) {
                $request->merge(['created_by' => $request->user()->user_id]);
            }
            // this shouldn't be needed but even if the db isn't setup to set
            // the time this ensures it will happen
            $request->merge(['created_at' => $Now]);
            $request->merge(['updated_at' => $Now]);
        } else {
            //Here we need to set updated_at and if possible, updated by
            $request->merge(['updated_at' => $Now]);
            if (!is_null($request->user())) {
                $request->merge(['updated_by' => $request->user()->user_id]);
            }
        }
        return $request;
    }

    /**
     * calls gets options from the request so that the filter array, limit, and
     * offset are available (if included in the request). Then calls APItoDB to
     * translate property names from API vernacular to proper DB naming and
     * saves the resulting object. The object is then reread from the DB (to
     * ensure that what is returned is in fact what is in the DB) and the result
     * send to the finishAndFilter method to be filtered and returned.
     * @param  request $request   The API request
     * @param  [type]  $Object    The pre existing object (if update)
     * @param  [type]  $Object_id The pre existing object_id (if update)
     * @return response           the respose object returned by finishAndFilter
     */
    protected function saveAndQuery(request $request, $Object)
    {
        // Convert the property names to match db and save
        $Object = $this::APItoDB($request, $Object);
        $query = $Object->save();

        //If we are saving something with a null id it must have been a create
        //so use the objects primary key to find the created id.
        $primaryId = is_null($this->RequestOptions->id) ? $Object[$Object->getKeyName()] : $this->RequestOptions->id;

        // Fetch the resulting object and return it
        $Query = App()->make(get_class($Object));
        $newObject = $this->queryWith($Query)->find($primaryId);
        return $this->finishAndFilter($newObject);
    }

    /**
     * called by the finishAndFilter customCollection method on each element of a collection
     *
     * @param  model  $Object object returned from the database
     * @param         $Filter  Array of properties the response objects should include
     * @return model object
     */
    protected function finishAndFilter($Object)
    {
        if (is_array($Object) || (!is_null($Object) && get_class($Object) == 'Illuminate\Database\Eloquent\Collection')) {
            foreach ($Object as $Key => $Element) {
                $Element = $this->finalize($Element);
                if (method_exists($Element, 'filterProperties')) {
                    $Element = $Element->filterProperties($Element, $this->RequestOptions->filter);
                }
                $Object[$Key] = $Element;
            }
        } else {
            $Object = $this->finalize($Object);
            if (!is_null($Object)) {
                if (method_exists($Object, 'filterProperties')) {
                    $Object = $Object->filterProperties($Object, $this->RequestOptions->filter);
                }
            }
        }
        if (isset($this->RequestOptions->limit) || isset($this->RequestOptions_offset)) {
            $Result = clone $Object;
            $Pagination = app()->make('stdClass');
            $Pagination->limit = $this->RequestOptions->limit;
            $Pagination->offset = $this->RequestOptions->offset;
            $Pagination->total = $this->RequestOptions->total_results;
            $Object = app()->make('stdClass');
            $Object->pagination = $Pagination;
            $Object->data = $Result;
        }
        return response()->json($Object, 200);
    }

    /**
     * Finalize method to be overridden as necessary in controllers so
     * objects can be manually adjusted with properties added or removed
     * prior to prop filtering.
     * @param  [type] $Object [description]
     * @return [type]         [description]
     */
    protected function finalize($Object)
    {
        return $Object;
    }
    protected function queryWith($Query)
    {
        return $Query;
    }
    protected function queryModifier($Query)
    {
        return $Query;
    }
    protected function getLock()
    {
        // lockable controller overrides this function and returns true
        // if the user was able to get the lock and false if they were not.
        // in this case, this stub function is used for "non lockable" endpoints
        // so it should always appear true.
        return true;
    }

    /**
     * Used to cast a generic object to a specific type
     * @param  object $instance  Generic object
     * @param  string $className Classname to cast to
     * @return Object after being cast
     */
    protected static function castObject($instance, string $className)
    {
        return unserialize(
            sprintf(
                'O:%d:"%s"%s',
                strlen($className),
                $className,
                strstr(strstr(serialize($instance), '"'), ':')
            )
        );
    }

    /**
     * See if the object has a property
     * @param  [type] $object   Object to test
     * @param  [type] $property property to look for
     * @return bool             true for success false for failure
     */
    protected static function objectHasProperty($object, $property)
    {
        return in_array($property, get_object_vars($object));
    }

    /**
     * In some cases a controller of one endpoint will use methods of another controller
     * When this happens it can be useful to apply new values to the request so that the
     * secondary controller can handle the request as any other api request. This method
     * maps properties of an object onto a request.
     * @param  request $request api request
     * @param  [type]  $object  object whos props should be transferred to the request
     */
    protected static function updateRequestFromObject(request $request, $object)
    {
        $ObjVars = array_keys(get_object_vars($object));

        foreach ($ObjVars as $ObjVar) {
            if ($request->input($ObjVar) === null) {
                $input[$ObjVar] = $object->$ObjVar;
            } else {
                $input[$ObjVar] = $request->input($ObjVar);
            }
        }

        $request->replace($input);
    }

    protected static function allocateTransactionNum()
    {
        $MaxTransaction = Vial::max('transaction');
        return $MaxTransaction < 800000 ? 800000 : $MaxTransaction + 1;
    }

    protected static function allocateBarcode()
    {
        $MaxBarcode = Vial::max('barcode');
        return $MaxBarcode < 100000 ? 100000 : $MaxBarcode + 1;
    }

    protected static function allocateRxNum()
    {
        $MaxRx = Prescription::max('prescription_num');
        return $MaxRx < 900000 ? 900000 : $MaxRx + 1;
    }
}
